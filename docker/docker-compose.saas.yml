# Argus SaaS — multi-service deployment
#
# Usage:
#   cp docker/saas.env.example .env.saas   # fill in your values
#   docker compose -f docker/docker-compose.saas.yml --env-file .env.saas up -d
#
# Architecture:
#   nginx (reverse proxy + WS upgrade)
#     → api    (FastAPI + thin WS handler)
#     → worker (AgentWorker — dequeues tasks, runs agent loops)
#   postgres    (operational data — users, tenants, conversations)
#   timescaledb (metrics + time-series)
#   redis       (task queue, pub/sub, API key cache)

services:
  # ----------------------------------------------------------
  # Reverse proxy — routes HTTP + WebSocket traffic
  # ----------------------------------------------------------
  nginx:
    image: nginx:1.27-alpine
    ports:
      - "0.0.0.0:${ARGUS_PROXY_PORT:-80}:80"
    volumes:
      - ./nginx/saas.conf:/etc/nginx/conf.d/default.conf:ro
    depends_on:
      api:
        condition: service_healthy
    restart: unless-stopped

  # ----------------------------------------------------------
  # API server — handles HTTP requests + thin WS connections
  # ----------------------------------------------------------
  api:
    image: ghcr.io/precious112/argus:${ARGUS_VERSION:-latest}
    build:
      context: ..
      dockerfile: Dockerfile.unified
    command: >
      python -m uvicorn argus_agent.main:app
      --host 0.0.0.0 --port 7600
      --workers ${ARGUS_API_WORKERS:-2}
    # env_file: ../.env.saas  (pass via --env-file flag instead)
    environment:
      - ARGUS_DEPLOYMENT__MODE=saas
      - ARGUS_MODE=${ARGUS_MODE:-sdk_only}
      - ARGUS_SERVER__PORT=7600
      - ARGUS_DEPLOYMENT__REDIS_URL=redis://redis:6379/0
      - ARGUS_DEPLOYMENT__POSTGRES_URL=postgresql+asyncpg://${POSTGRES_USER:-argus}:${POSTGRES_PASSWORD:-argus}@postgres:5432/${POSTGRES_DB:-argus}
      - ARGUS_DEPLOYMENT__TIMESCALE_URL=postgresql://${TIMESCALE_USER:-argus}:${TIMESCALE_PASSWORD:-argus}@timescaledb:5432/${TIMESCALE_DB:-argus_metrics}
      - ARGUS_DEPLOYMENT__FRONTEND_URL=${ARGUS_FRONTEND_URL:-http://localhost:3000}
      - ARGUS_LLM__PROVIDER=${ARGUS_LLM_PROVIDER:-openai}
      - ARGUS_LLM__API_KEY=${ARGUS_LLM_API_KEY:-}
      - ARGUS_LLM__MODEL=${ARGUS_LLM_MODEL:-gpt-4o}
      - ARGUS_SECURITY__SECRET_KEY=${ARGUS_SECRET_KEY:-}
      - ARGUS_DEPLOYMENT__POLAR_ACCESS_TOKEN=${ARGUS_POLAR_ACCESS_TOKEN:-}
      - ARGUS_DEPLOYMENT__POLAR_WEBHOOK_SECRET=${ARGUS_POLAR_WEBHOOK_SECRET:-}
      - ARGUS_DEPLOYMENT__POLAR_TEAMS_PRODUCT_ID=${ARGUS_POLAR_TEAMS_PRODUCT_ID:-}
      - ARGUS_DEBUG=${ARGUS_DEBUG:-false}
    depends_on:
      postgres:
        condition: service_healthy
      timescaledb:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7600/api/v1/health"]
      interval: 15s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  # ----------------------------------------------------------
  # Agent worker — dequeues tasks from Redis, runs LLM loops
  # ----------------------------------------------------------
  worker:
    image: ghcr.io/precious112/argus:${ARGUS_VERSION:-latest}
    build:
      context: ..
      dockerfile: Dockerfile.unified
    command: python -m argus_agent.queue.worker
    # env_file: ../.env.saas  (pass via --env-file flag instead)
    environment:
      - ARGUS_DEPLOYMENT__MODE=saas
      - ARGUS_MODE=${ARGUS_MODE:-sdk_only}
      - ARGUS_DEPLOYMENT__REDIS_URL=redis://redis:6379/0
      - ARGUS_DEPLOYMENT__POSTGRES_URL=postgresql+asyncpg://${POSTGRES_USER:-argus}:${POSTGRES_PASSWORD:-argus}@postgres:5432/${POSTGRES_DB:-argus}
      - ARGUS_DEPLOYMENT__TIMESCALE_URL=postgresql://${TIMESCALE_USER:-argus}:${TIMESCALE_PASSWORD:-argus}@timescaledb:5432/${TIMESCALE_DB:-argus_metrics}
      - ARGUS_LLM__PROVIDER=${ARGUS_LLM_PROVIDER:-openai}
      - ARGUS_LLM__API_KEY=${ARGUS_LLM_API_KEY:-}
      - ARGUS_LLM__MODEL=${ARGUS_LLM_MODEL:-gpt-4o}
      - ARGUS_SECURITY__SECRET_KEY=${ARGUS_SECRET_KEY:-}
      - ARGUS_DEBUG=${ARGUS_DEBUG:-false}
    deploy:
      replicas: ${ARGUS_WORKER_REPLICAS:-1}
    depends_on:
      postgres:
        condition: service_healthy
      timescaledb:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped

  # ----------------------------------------------------------
  # PostgreSQL — operational data (users, tenants, etc.)
  # ----------------------------------------------------------
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-argus}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-argus}
      POSTGRES_DB: ${POSTGRES_DB:-argus}
    volumes:
      - pg_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-argus}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  # ----------------------------------------------------------
  # TimescaleDB — time-series metrics
  # ----------------------------------------------------------
  timescaledb:
    image: timescale/timescaledb:latest-pg16
    environment:
      POSTGRES_USER: ${TIMESCALE_USER:-argus}
      POSTGRES_PASSWORD: ${TIMESCALE_PASSWORD:-argus}
      POSTGRES_DB: ${TIMESCALE_DB:-argus_metrics}
    volumes:
      - ts_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${TIMESCALE_USER:-argus}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped

  # ----------------------------------------------------------
  # Redis — task queue, pub/sub, API key cache
  # ----------------------------------------------------------
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 5s
    restart: unless-stopped

volumes:
  pg_data:
  ts_data:
  redis_data:
